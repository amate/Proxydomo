<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content=
"HTML Tidy for Windows (vers 1st April 2002), see www.w3.org">
<title>Proximodo - Коды и команды</title>
<link rel="stylesheet" type="text/css" href="help.css">
</head>
<body>

<p class="section">Специальные коды сопоставления</p>

<table>
<tr>
<td>
<p><span class="syntax">*</span></p>
</td>
<td>
<p>любой текст, любой длины (даже нулевой)<br>
 <span class="example">foo*bar</span> будет соответствовать <span class=
"extext">foobar</span>, <span class="extext">foo-bar</span>, <span
class="extext">foodoodlebar</span></p>
</td>
</tr>

<tr>
<td>
<p><span class="syntax">?</span></p>
</td>
<td>
<p>любой одиночный символ</p>
</td>
</tr>

<tr>
<td>
<p><span class="syntax">[</span>abc<span class=
"syntax">]</span></p>
</td>
<td>
<p>любой единичный символ представленный в <span class=
"example">[]</span><br>
 Включает определенный диапазон (нечувствительный к регистру), выделенный первым и последним символами минус знаки (пример <span class="example">[abc0-9]</span> означает, что необходимо искать только буквы "a" "b" "c" и числа от 0 до 9 включительно). Также вы можете использовать \ для исключения символа, и %hh (где hh шестнадцатеричное число) определенное в ASCII кодировке. Знаки \ и % чувствительны к регистру, и могут быть использованы для определения диапазона (в этом случае, диапазон становится чувствительным к регистру).</p>
</td>
</tr>

<tr>
<td>
<p><span class="syntax">[^</span>abc<span class=
"syntax">]</span></p>
</td>
<td>
<p>любой единичный символ НЕ представленный в <span class=
"example">[]</span>. <span class="example">[^abc0-9]</span> означает, что надо искать любой символ кроме букв "a" "b" "c" и чисел от 0 до 9. 
</p>
</td>
</tr>

<tr>
<td>
<p><span class="syntax">[#</span>n<span class=
"syntax">:</span>m<span class="syntax">]</span></p>
</td>
<td>
<p>целое число если оно входит в диапазон<br>
 Разрешено использовать отрицательные числа. Используйте * слева для минус бесконечности, * справа для плюс бесконечности. <span class="example">[#n]</span> тоже самое, что и <span class="example">[#n:n]</span><br>
<span class="example">[#100]</span> искать число 100.<br>
<span class="example">[#100-150]</span> искать числа от 100 до 150.<br>
<span class="example">[#40-*]</span> искать числа больше 40.</p>
</td>
</tr>

<tr>
<td>
<p>пробел</p>
</td>
<td>
<p>отсутствие пробела или несколько пробелов или табуляций или CR или LF</p>
</td>
</tr>

<tr>
<td>
<p><span class="syntax">\s</span></p>
</td>
<td>
<p>один пробел</p>
</td>
</tr>

<tr>
<td>
<p><span class="syntax">\r</span></p>
</td>
<td>
<p>символ возврата каретки</p>
</td>
</tr>

<tr>
<td>
<p><span class="syntax">\n</span></p>
</td>
<td>
<p>символ новая строка</p>
</td>
</tr>

<tr>
<td>
<p><span class="syntax">\t</span></p>
</td>
<td>
<p>символ табуляции</p>
</td>
</tr>

<tr>
<td>
<p><span class="syntax">\w</span></p>
</td>
<td>
<p>слово (возможно нулевой длины)<br>
 Слово может состоять из любых символов кроме пробела, табуляции, CR, LF,
и "&gt;" (который обозначает конец HTML тега)</p>
</td>
</tr>

<tr>
<td>
<p><span class="syntax">\0</span> ... <span class=
"syntax">\9</span></p>
</td>
<td>
<p>тоже, что и <span class="example">*</span>, но найденный текст сохраняется в переменой вида \1, \2, ...\9<br>
 Сохраненный текст может быть использован в тексте замены.<br><br>
<FONT SIZE="2" COLOR="#AA0000">Соответствие:</FONT> &lt;body \1 background="*" \2 &gt;<br>
<FONT SIZE="2" COLOR="#AA0000">Замена:</FONT> &lt;body \1 background="mybackground.gif" \2 &gt;<br><br></p>
</td>
</tr>

<tr>
<td>
<p><span class="syntax">\#</span></p>
</td>
<td>
<p>тоже, что и <span class="example">*</span>, но текст сохраняется в очередь<br>
 Сохраненный текст можно использовать в тексте замены используя <span class="example">\#</span> или <span class=
"example">\@</span></p>
</td>
</tr>

<tr>
<td>
<p>...<span class="syntax">|</span>...</p>
</td>
<td>
<p>левый шаблон или правый шаблон<br>
 Соответствует функции "ИЛИ". <span class="example">foo|bar</span> будет искать сначала <span class="extext">foo</span>, а затем, если не найдет, <span class="extext">bar</span>. Оператор <span class=
"example">|</span> имеет более высокий приоритет чем <span class="example">&amp;</span> и 
<span class="example">&amp;&amp;</span>, но меньший чем все другие символы.</p>
</td>
</tr>

<tr>
<td>
<p>...<span class="syntax">&amp;</span>...</p>
</td>
<td>
<p>левый шаблон и правый шаблон<br>
 Соответствует функции "И". <span class=
"example">*foo&amp;*bar</span> будет искать только если оба слова <span class="extext">foo</span> и <span class="extext">bar</span> будут в тексте, для примера <span class="extext">doobardoofoo</span>, <span class="extext">bar foo</span>, но не <span class="extext">foo foo</span>. Этот оператор имеет более низкий приоритет чем другие операторы.</p>
</td>
</tr>

<tr>
<td>
<p>...<span class="syntax">&amp;&amp;</span>...</p>
</td>
<td>
<p>левый шаблон, и правый шаблон с текстом обработанным левой частью<br>
 Различие с <span class="example">&amp;</span> в том, что правый шаблон будет ограничен тем, что обрабатывает левый шаблон, и должен обрабатывать такую же длину.</p>
</td>
</tr>

<tr>
<td>
<p><span class="syntax">(</span>...<span class=
"syntax">)</span></p>
</td>
<td>
<p>шаблон ищет соответствие с скобками<br>
 Вы можете использовать в скобках группы разделенные <span class="example">|</span> или скобки совместно с <span
class="example">+</span>. Например, <span class="example">(foo|bar)+</span> будет искать <span class="extext">foobarfoofoobar</span></p>
</td>
</tr>

<tr>
<td>
<p><span class="syntax">(^</span>...<span class=
"syntax">)</span></p>
</td>
<td>
<p>обрабатывает (без использования чего-либо) если нет вложенного шаблона.<br>
Вы можете использовать <span class="example">(^(^...))</span> для тестирования шаблона, но не для использования. Имейте ввиду, что если скобки содержат полный шаблон, они опциональны.</p>
</td>
</tr>

<tr>
<td>
<p><span class="syntax">(</span>...<span class=
"syntax">)\#</span><br>
 <span class="syntax">(</span>...<span class="syntax">)\0</span>
<span class="syntax">...\9</span></p>
</td>
<td>
<p>тоже, что и <span class="example">(...)</span>, но найденный текст сохраняется в переменные или в очередь.</p>
</td>
</tr>

<tr>
<td>
<p>...<span class="syntax">+</span></p>
</td>
<td>
<p>предшествующий символ повторяется нуль или более раз<br>
 <span class="example">ab+</span> будет соответствовать <span class="extext">a</span>, <span class="extext">ab</span>, <span class="extext">abbb</span>, но не <span class="extext">aaab</span>.
<span class="example">(ab)+</span> будет искать <span class=
"extext">ab</span>, <span class="extext">abab</span>, <span class=
"extext">ababab</span>, или нуль символов.</p>
</td>
</tr>

<tr>
<td>
<p>...<span class="syntax">+{</span>n<span class=
"syntax">,</span>m<span class="syntax">}</span></p>
</td>
<td>
<p>предшествующий символ повторяется столько раз сколько ограничивается числами n и m<br>
 <span class="example">a+{2,4}</span> будет соответствовать <span class="extext">aa</span>, <span class="extext">aaa</span>, <span class="extext">aaaa</span>, но не <span class="extext">a</span> или <span
class="extext">aaaaa</span>. Используйте * слева для нуля, * справа для плюс бесконечности. <span class="example">+{n}</span> тоже, что и <span class="example">+{n,n}</span> ("должно повториться n раз"). Звездочки опционально.</p>
</td>
</tr>

<tr>
<td>
<p>...<span class="syntax">++</span></p>
</td>
<td>
<p>тоже, что и <span class="example">+</span>, но может искать меньшее число символов, чем может найти<br>
 <span class="example">+</span>. Например, <span class=
"example">a+ab</span> не найдет <span class=
"extext">aaab</span>, а <span class="example">a++ab</span>
сможет найти это выражение. <span class="example">++</span> работает медленнее. Используйте <span
class="example">++{n,m}</span> для определения минимального и максимального числа повторений.</p>
</td>
</tr>

<tr>
<td>
<p><span class="syntax">\</span>...</p>
</td>
<td>
<p>следующий символ в шаблоне<br>
 Это символ для нахождения специальных символов.
<span class="example">a\*b</span> будет искать <span class="extext">a*b</span>.</p>
</td>
</tr>

<tr>
<td>
<p><span class="syntax">=</span></p>
</td>
<td>
<p>знак равно и равенство пробелов до и после него<br>
 Упрощает сопоставление html тегов. Вы не будете беспокоиться о возможных параметрах тега до/после пробела в html коде.</p>
</td>
</tr>

<tr>
<td>
<p><span class="syntax">"</span></p>
</td>
<td>
<p>одинарная кавычка или двойная кавычка<br>
 Упрощает сопоставление html тегов. Вы не будете беспокоиться если параметры тега имеют одинарные или двойные кавычки.<br><br>
<FONT SIZE="2" COLOR="#AA0000">Например</FONT> "*" соответствует <b>"любой текст"</b> или <b>'любой текст'</b>
</p>
</td>
</tr>

<tr>
<td>
<p><span class="syntax">'</span> (кавычка)</p>
</td>
<td>
<p>одинарная кавычка, если открывающая, двойная, если закрывающая<br>
 Позволяет искать вложенные кавычки. <span class="example">"*'</span> будет соответствовать <span class="extext">"foo 'doodle' bar"</span>, а не <span class="extext">"foo '</span></p>
</td>
</tr>

<tr>
<td>
<p><span class="syntax">\h</span></p>
</td>
<td>
<p>часть URL соответствующая хосту </p>
</td>
</tr>

<tr>
<td>
<p><span class="syntax">\q</span></p>
</td>
<td>
<p>часть URL соответствующая запросу (следующая за "?")</p>
</td>
</tr>

<tr>
<td>
<p><span class="syntax">\p</span></p>
</td>
<td>
<p>часть URL соответствующая пути (следующая за "/")</p>
</td>
</tr>

<tr>
<td>
<p><span class="syntax">\a</span></p>
</td>
<td>
<p>якорь из URL (включая "#")</p>
</td>
</tr>

<tr>
<td>
<p><span class="syntax">\u</span></p>
</td>
<td>
<p>любой URL (включая ://)</p>
</td>
</tr>

<tr>
<td>
<p><span class="syntax">\k</span></p>
</td>
<td>
<p>нулевой символ, уничтожает соединение<br>
В текстовых фильтрах, исключает данные после замещающего текста.</p>
</td>
</tr>

<tr>
<td>
<p><span class="syntax">&lt;start&gt;</span></p>
</td>
<td>
<p>начало текста<br>
Этот код должен использоваться в шаблоне текстового фильтра для эффективности. Он ничего не удаляет, но позволяет включать некоторый текст в самом начале файла. Он будет обрабатывать данные только один раз и границы шаблона, размер и многократное использование не принимаются во внимание.</p>
</td>
</tr>

<tr>
<td>
<p><span class="syntax">&lt;end&gt;</span></p>
</td>
<td>
<p>конец текста<br>
Этот код должен использоваться в шаблоне текстового фильтра для эффективности. Он ничего не удаляет, но позволяет включать некоторый текст в самом конце файла. Он будет обрабатывать данные только один раз и границы шаблона, размер и многократное использование не принимаются во внимание.</p>
</td>
</tr>
</table>

<p class="section">Специальные коды замены</p>

<table>

<tr>
<td>
<p><span class="syntax">\h</span></p>
</td>
<td>
<p>часть URL соответствующая хосту </p>
</td>
</tr>

<tr>
<td>
<p><span class="syntax">\q</span></p>
</td>
<td>
<p>часть URL соответствующая запросу (следующая за "?")</p>
</td>
</tr>

<tr>
<td>
<p><span class="syntax">\p</span></p>
</td>
<td>
<p>часть URL соответствующая пути (следующая за "/")</p>
</td>
</tr>

<tr>
<td>
<p><span class="syntax">\a</span></p>
</td>
<td>
<p>якорь из URL (включая "#")</p>
</td>
</tr>

<tr>
<td>
<p><span class="syntax">\u</span></p>
</td>
<td>
<p>весь URL (включая протокол)</p>
</td>
</tr>

<tr>
<td>
<p><span class="syntax">\k</span></p>
</td>
<td>
<p>уничтожает соединение<br>
</p>
</td>
</tr>

</tr>

<tr>
<td>
<p><span class="syntax">\0</span> ... <span class=
"syntax">\9</span></p>
</td>
<td>
<p>соответствующий текст записанный последним в границах шаблонов</p>
</td>
</tr>

<tr>
<td>
<p><span class="syntax">\#</span></p>
</td>
<td>
<p>следующая записанная в очередь строка в границах шаблонов</p>
</td>
</tr>

<tr>
<td>
<p><span class="syntax">\@</span></p>
</td>
<td>
<p>все оставшиеся строки в очереди</p>
</td>
</tr>

<tr>
<td>
<p><span class="syntax">\</span>...</p>
</td>
<td>
<p>следующий символ обрабатывается как не специальный. Используется для поиска "\", "$", "(" или ")".</p>
</td>
</tr>
</table>

<p class="section">Команды</p>

<p>Команды могут использоваться в шаблонах ( <span class=
"indic">M</span> ) или в замещающем тексте ( <span class=
"indic">R</span> ).<br>
 Если не указано особо, команды в шаблонах обрабатывают данные без поглощения символов.<br>
 Команды в замещающем тексте могут обрабатываться или нет. Когда они не обрабатываются,
замещающий текст останавливается в данной точке, которая означает, что замена произошла, но не включает текст после необработанной команды ( и следующие команды не выполнены). Если не указано особо, команды в замещающем тексте всегда обрабатываются.<br>
 Поскольку команды могут быть вложеными, вы должны убедиться, что круглые скобки последовательны. Если вам нужно обрабатывать сами символы круглых скобок исключите их.<br>
 Неизвестные команды игнорируются, так что вы можете использовать команду
<span class="example">$NOP(для игнорирования текста)</span> для отключения части шаблона включающего некоторый комментарий.</p>

<table>
<tr>
<td width="20">
<p><span class="indic">M</span></p>
</td>
<td width="20">
<p><span class="indic">R</span></p>
</td>
<td>
<p class="command">$ADDLST(Имя списка, добавление текста)</p>

<p>Добавляет строки в список<br>
 Строка немедленно добавляется в файл. Если шаблон правильный, то эффект будет мгновенным для всех команд $LST, которые используют этот список.<br>
Возможно добавление строки к списку не определено в GUI: в этом случае строка не добавляется в файл, но остается доступной в памяти для последующих команд $LST, пока приложение работает или пока число строк не превысит 1000 - это фиксированный размер виртуального списка.</p>
</td>
</tr>

<tr>
<td>
<p><span class="indic">M</span></p>
</td>
<td>
<p><span class="indic">R</span></p>
</td>
<td>
<p class="command">$ADDLSTBOX(Имя списка, [расширенный заголовок,] добавление текста)</p>

<p>Тоже, что и $ADDLST, но будет спрошено у пользователя.<br>
 Пользователь может изменить строку или отменить добавление.</p>
</td>
</tr>

<tr>
<td>
<p><span class="indic">M</span></p>
</td>
<td>
<p><span class="indic">R</span></p>
</td>
<td>
<p class="command">$ALERT(текст)</p>

<p>Показывает диалог сообщения.<br>
 Фильтр ждет пока пользователь нажмет на кнопку OK.</p>
</td>
</tr>

<tr>
<td>
<p><span class="indic">M</span></p>
</td>
<td>
<p><br>
</p>
</td>
<td>
<p class="command">$ASK(Список разрешенных, Список запрещенных, запрос,
добавление текста [, поиск текста])</p>

<p>Запрос пользователя о добавлении текста в список разрешенных или запрещенных.<br>
 Найденный текст (по умолчанию URL без http://) ищется в двух списках (похоже на две команды $LST). Если проверяется список разрешенных команда $ASK не обрабатывается. Если проверяется список запрещенных, команда $ASK обрабатывается. Появится сообщение на экране, показывая текст для добавления, и у пользователя спросят добавить его или нет. Если пользователь выберет да, то текст будет добавлен в список разрешенных (похоже на команду $ADDLST) и команда $ASK не будет обрабатываться. Если пользователь выберет нет, то текст будет добавлен в список запрещенных и команда $ASK будет обработана.<br>
 Примечание: сообщения для списка запрещенных вместо разрешенных позволяет фильтрам обходить разрешенные URL.</p>
</td>
</tr>

<tr>
<td>
<p><span class="indic">M</span></p>
</td>
<td>
<p><br>
</p>
</td>
<td>
<p class="command">$AV(шаблон)</p>

<p>Расположение последнего параметра HTML тега, который может быть простым словом или строкой заключенной в одинарные или двойные кавычки. Затем шаблон будет содержать значение тега (без кавычек). Если шаблон соответствует значению тега, $AV обрабатывается и тег поглощается (включая кавычки).<br> src=$AV(\1) будет искать и поглощать src="url" и \1 будет содержать url.</p>
</td>
</tr>

<tr>
<td>
<p><span class="indic">M</span></p>
</td>
<td>
<p><br>
</p>
</td>
<td>
<p class="command">$AVQ(шаблон)</p>

<p>Тоже, что и $AV, но шаблон будет содержать значение тега с кавычками.<br>
 src=$AV(\1) будет искать и поглощать src="url" и \1 будет содержать "url"</p>
</td>
</tr>

<tr>
<td>
<p><span class="indic">M</span></p>
</td>
<td>
<p><br>
</p>
</td>
<td>
<p class="command">$CON:(x,y[,z])</p>

<p>Обрабатывается если число соединений "x из y". Ротация происходит при каждых z соединениях (по умолчанию 1).<br>
 Параметра должны быть только положительными целыми.</p>
</td>
</tr>

<tr>
<td>
<p><span class="indic">M</span></p>
</td>
<td>
<p><span class="indic">R</span></p>
</td>
<td>
<p class="command">$CONFIRM(текст)</p>

<p>Показывает сообщение для выбора с кнопками Да/Нет. Обрабатывается только если пользователь нажмет Да.</p>
</td>
</tr>

<tr>
<td>
<p><br>
</p>
</td>
<td>
<p><span class="indic">R</span></p>
</td>
<td>
<p class="command">$DTM(формат)</p>

<p>Генерирует строку дата/время, следуя выбранному формату.<br>
 Формат может содержать любой символ, плюс следующие специальные коды:<br>
</p>

<table>
<tr>
<td>
<ul>
<li>Y : год</li>

<li>M : месяц</li>

<li>D : день</li>

<li>H : часов (00-23)</li>

<li>h : часов (01-12)</li>

<li>a : (am/pm)</li>

<li>m : минут</li>

<li>s : секунд</li>
</ul>
</td>
<td>
<ul>
<li>t : миллисекунд</li>

<li>w : три буквы дня недели (Вос,Пон,Вто...)</li>

<li>T : соответствует H:m:s</li>

<li>U : соответствует M/D/Y</li>

<li>E : соответствует D/M/Y</li>

<li>d : соответствует Y-M-D</li>

<li>I : Internet formatted UTC</li>

<li>c : текущий номер соединения</li>
</ul>
</td>
</tr>
</table>
</td>
</tr>

<tr>
<td>
<p><br>
</p>
</td>
<td>
<p><span class="indic">R</span></p>
</td>
<td>
<p class="command">$ESC(текст)</p>

<p>Преобразует не-текстовые символы в их код вида %xx.<br>
 Противоположно $UESC</p>
</td>
</tr>

<tr>
<td>
<p><br>
</p>
</td>
<td>
<p><span class="indic">R</span></p>
</td>
<td>
<p class="command">$FILE(имя файла)</p>

<p>Включает содержимое файла в замещающую строку.<br>
 Путь может быть абсолютным или относительным директории Proximodo. Используйте \\ или / в пути.</p>
</td>
</tr>

<tr>
<td>
<p><span class="indic">M</span></p>
</td>
<td>
<p><span class="indic">R</span></p>
</td>
<td>
<p class="command">$FILTER(истинно или ложно)</p>

<p>Активирует или деактивирует все текстовые фильтры для этого запроса.<br>
 Работает только в фильтрах заголовков.</p>
</td>
</tr>

<tr>
<td>
<p><br>
</p>
</td>
<td>
<p><span class="indic">R</span></p>
</td>
<td>
<p class="command">$GET(имя переменной)</p>

<p>Выбирает значение переменной.<br>
 Величина не расширенная ( расширенная величина устанавливается посредством команды $SET).</p>
</td>
</tr>

<tr>
<td>
<p><span class="indic">M</span></p>
</td>
<td>
<p><span class="indic">R</span></p>
</td>
<td>
<p class="command">$IHDR(заголовок:шаблон)</p>

<p>Обрабатывается если выбранный входящий заголовок соответствует данному шаблону.</p>
</td>
</tr>

<tr>
<td>
<p><span class="indic">M</span></p>
</td>
<td>
<p><br>
</p>
</td>
<td>
<p class="command">$INEST(начальный шаблон, [внутренний шаблон], конечный шаблон)</p>

<p>Данная команда похожа на $NEST, но считает, что стартовый шаблон был поглощен и не поглощает конечный тег.</p>
</td>
</tr>

<tr>
<td>
<p><span class="indic">M</span></p>
</td>
<td>
<p><span class="indic">R</span></p>
</td>
<td>
<p class="command">$JUMP(http://some.url.com/)</p>

<p>Посылает фальшивый ответ переадресации (команда 302) браузеру.</p>
</td>
</tr>

<tr>
<td>
<p><span class="indic">M</span></p>
</td>
<td>
<p><span class="indic">R</span></p>
</td>
<td>
<p class="command">$KEYCHK(список кодов клавиш)</p>

<p>Наблюдает за нажатием определенных клавиш.<br>
 Список может содержать любую букву или символ (соответствующий клавише на клавиатуре, например A) или следующие ^- коды:</p>

<ul>
<li>^C : Ctrl</li>

<li>^A : Alt</li>

<li>^S : Shift</li>

<li>^T : Tab</li>

<li>^F1 : функциональные клавиши F1 и т.д.</li>

<li>^число : число соответствует ascii значению, например ^32 это пробел</li>
</ul>
</td>
</tr>

<tr>
<td>
<p><span class="indic">M</span></p>
</td>
<td>
<p><span class="indic">R</span></p>
</td>
<td>
<p class="command">$LOCK()</p>

<p>Ожидает пока любой другой фильтр, который запущен до этого командой $LOCK (не зависимо от связи) выполнит $UNLOCK.<br> Этот - принцип известен как "Mutex". Только один mutex есть у Proximodo для фильтров, и только один фильтр может иметь его в текущее время.</p>
</td>
</tr>

<tr>
<td>
<p><span class="indic">M</span></p>
</td>
<td>
<p><span class="indic">R</span></p>
</td>
<td>
<p class="command">$LOG([!]Xтекст)</p>

<p>Посылает некоторый текст в окно отчета. Если "!" присутствует, то окно отчета открывается и начинает работать.<br>
 X - единственная буква, которая указывает цвет строки в окне. Может принимать одно из следующих значений:<br>
 R: красный, G: зеленый, B: синий, Y: желтый, V: фиолетовый, C: голубой, W: белый, w: серый</p>
</td>
</tr>

<tr>
<td>
<p><span class="indic">M</span></p>
</td>
<td>
<p><br>
</p>
</td>
<td>
<p class="command">$LST(Имя списка)</p>

<p>Пытается обработать шаблоны в списке один после другого.<br>
 Например ((...)|(...)|(...)|(...)) со всеми строками в списке.<br>
 Строки начинающиеся с #, пустые строки и неправильные шаблоны исключаются.</p>
</td>
</tr>

<tr>
<td>
<p><span class="indic">M</span></p>
</td>
<td>
<p><br>
</p>
</td>
<td>
<p class="command">$NEST(начальный шаблон, [внутренний шаблон], конечный шаблон)</p>

<p>Обрабатывает и поглощает вложенные теги.<br>
 Если текст соответствует первому шаблону, $NEST пытается найти соответствие конечному шаблону. Если оно найдено,
$NEST поглощает текст вплоть до конца конечного тега.<br>
 Но может быть дополнительное условие: если внутренний шаблон присутствует, проверяется текст между начальным и конечным тегами. Если ничего не найдено, то $NEST не сработает.</p>
</td>
</tr>

<tr>
<td>
<p><span class="indic">M</span></p>
</td>
<td>
<p><span class="indic">R</span></p>
</td>
<td>
<p class="command">$OHDR(заголовок:шаблон)</p>

<p>Обрабатывается если выбранный исходящий заголовок соответствует данному шаблону.</p>
</td>
</tr>

<tr>
<td>
<p><span class="indic">M</span></p>
</td>
<td>
<p><span class="indic">R</span></p>
</td>
<td>
<p class="command">$RDIR(http://some.url.com/)</p>

<p>Прозрачно перенаправляет на другой URL.<br>
 Браузер не узнает о переадресации.</p>
</td>
</tr>

<tr>
<td>
<p><span class="indic">M</span></p>
</td>
<td>
<p><span class="indic">R</span></p>
</td>
<td>
<p class="command">$RESP(шаблон)</p>

<p>Пытается получить ответный код (3 цифры следующие за пробелом и ответным сообщением<br>
 Бесполезно использовать в фильтре исходящих заголовков (код ответа неизвестен в это время).</p>
</td>
</tr>

<tr>
<td>
<p><span class="indic">M</span></p>
</td>
<td>
<p><span class="indic">R</span></p>
</td>
<td>
<p class="command">$SET(\# или \0-\9=текст)</p>

<p>Сохраняет текст в переменные или очередь.<br>
 Текст не расширенный в этой точке, расширение происходит когда значение извлечено в замещающий текст с \# или \0.</p>
</td>
</tr>

<tr>
<td>
<p><span class="indic">M</span></p>
</td>
<td>
<p><span class="indic">R</span></p>
</td>
<td>
<p class="command">$SET(переменная=текст)</p>

<p>Сохраняет текст в переменную.<br>
 Необходима область памяти для переменной: переменные используются всеми фильтрами обрабатывающими тот же запрос. Т.о. вы можете установить переменную в фильтре заголовков и использовать ее в фильтре текста.<br>
 Примечание: имя переменной чувствительно к регистру.</p>
</td>
</tr>

<tr>
<td>
<p><span class="indic">M</span></p>
</td>
<td>
<p><span class="indic">R</span></p>
</td>
<td>
<p class="command">$SETPROXY(удаленный.прокси.имя[:порт])</p>

<p>Заставляет использовать конкретный прокси-сервер.<br>
 Прокси должен быть в списке доступном в настройках Proximodo. Вам не надо писать все имя, первых букв будет достаточно.<br>
 Работает только в фильтрах исходящих заголовков (после соединение, а также позже).</p>
</td>
</tr>

<tr>
<td>
<p><span class="indic">M</span></p>
</td>
<td>
<p><span class="indic">R</span></p>
</td>
<td>
<p class="command">$STOP()</p>

<p>Отключает фильтр.<br>
 По ее достижении фильтр будет выключен до конца страницы/соединения. Текущее совпадение будет доведено до конца, но поиск следующих производиться не будет.</p>
</td>
</tr>

<tr>
<td>
<p><span class="indic">M</span></p>
</td>
<td>
<p><br>
</p>
</td>
<td>
<p class="command">$TST(\# или \0-\9)</p>

<p>Пытается найти текст шаблона сохраненный в переменную (или последний в очереди).</p>
</td>
</tr>

<tr>
<td>
<p><span class="indic">M</span></p>
</td>
<td>
<p><span class="indic">R</span></p>
</td>
<td>
<p class="command">$TST(\# или \0-\9=шаблон)</p>

<p>Обрабатывается, если содержимое переменной (или последний элемент очереди) соответствует шаблону.<br>
Но не работает, если переменная пустая.</p>
</td>
</tr>

<tr>
<td>
<p><span class="indic">M</span></p>
</td>
<td>
<p><br>
</p>
</td>
<td>
<p class="command">$TST(имя переменной)</p>

<p>Пытается найти (и поглотить) текст сохраненный в переменной.</p>
</td>
</tr>

<tr>
<td>
<p><span class="indic">M</span></p>
</td>
<td>
<p><span class="indic">R</span></p>
</td>
<td>
<p class="command">$TST(имя переменной=шаблон)</p>

<p>Обрабатывается, если содержимое переменной (или последний элемент очереди) соответствует шаблону.<br>
Но не работает, если переменная пустая.</p>
</td>
</tr>

<tr>
<td>
<p><span class="indic">M</span></p>
</td>
<td>
<p><br>
</p>
</td>
<td>
<p class="command">$TST((текст))</p>

<p>Пытается найти (и поглотить) текст шаблона, полученный расширенным параметром.</p>
</td>
</tr>

<tr>
<td>
<p><span class="indic">M</span></p>
</td>
<td>
<p><span class="indic">R</span></p>
</td>
<td>
<p class="command">$TST((текст)=шаблон)</p>

<p>Обрабатывает, если расширенный текст соответствует шаблону.<br>
Но не работает, если расширенный текст пустой..</p>
</td>
</tr>

<tr>
<td>
<p><span class="indic">M</span></p>
</td>
<td>
<p><br>
</p>
</td>
<td>
<p class="command">$TYPE(код)</p>

<p>Обрабатывает типы файлов.<br>
 Например:</p>

<ul>
<li>htm : html документ</li>

<li>css : css таблица стилей</li>

<li>js : javascript</li>

<li>vbs : VBscript</li>

<li>oth : другой тип</li>
</ul>

<p>Примечание: это - только базовая оценка основанная на нескольких признаках в начале файла (для фильтров текста) или по расширению файлов (для фильтров заголовков). Используйте $IHDR(Content-Type=...) для более надежного тестирования.</p>
</td>
</tr>

<tr>
<td>
<p><br>
</p>
</td>
<td>
<p><span class="indic">R</span></p>
</td>
<td>
<p class="command">$UESC(текст)</p>

<p>Заменяет все %nn коды в тексте соответствующим ascii символом.<br>
 Противоположность $ESC.</p>
</td>
</tr>

<tr>
<td>
<p><span class="indic">M</span></p>
</td>
<td>
<p><span class="indic">R</span></p>
</td>
<td>
<p class="command">$UNLOCK()</p>

<p>Освобождает mutex зарезервированный командой $LOCK.<br>
 Нет необходимости использовать эту команду, поскольку она автоматически выполняется в конце работы фильтра.</p>
</td>
</tr>

<tr>
<td>
<p><span class="indic">M</span></p>
</td>
<td>
<p><span class="indic">R</span></p>
</td>
<td>
<p class="command">$URL(шаблон)</p>

<p>Проверяется соответствие URL шаблону.</p>
</td>
</tr>

<tr>
<td>
<p><span class="indic">M</span></p>
</td>
<td>
<p><span class="indic">R</span></p>
</td>
<td>
<p class="command">$USEPROXY(истина или ложь)</p>

<p>Заставляет Proximodo использовать или не использовать прокси для доступа в интернет.<br>
 Прокси один из выбранных в настройках Proximodo.</p>
</td>
</tr>

<tr>
<td>
<p><br>
</p>
</td>
<td>
<p><span class="indic">R</span></p>
</td>
<td>
<p class="command">$WESC(текст)</p>

<p>Команда похожа на $ESC, но только для специальных символов.</p>
</td>
</tr>
</table>
</body>
</html>

